<?php

/**
 * @file datatable.module
 * @author Ramon Gamma, 2012
 * @copyright 2012 Naturwerk, Brugg
 */

/**
 * Implements hook_theme()
 *
 * @return an array with theme template information
 */

function datatable_theme() {
	return array(
			'datatable' => array(
					'template' => 'datatable',
					'variables' => array(
							// id of html table element
							'id_table' => NULL,
							// header of tables with a json URL
							'header' => NULL,
							// content of table similar to table theme
							'rows' => NULL,
							// height and width of displayed datatable in pixel
							'tableWidth' => NULL,
							'tableHeight' => NULL,
							'len' => NULL,
							// Array of options to be set for the jquery datatable plugin where the key is the option name and the value is the javascript value as a string
							'options' => NULL,
							'dbFields' => NULL,
							// Table title
							'title' => NULL
					),
			),
	);
}

/**
 * Function for other modules to progress the data from the db to the json
 * Fields from and for http://datatables.net
 * $_Request is used for filtering
 *
 * @note Some values get submitted from flexigrid via POST:
 * 	- sortname	Name of the colomn to be sorted at
 * 	- sortorder Sortoder (asc or desc)
 * 	- query		The phrase searched for (will be used case insensitive)
 * 	- page		Which page to show in case there are more elements than
 * 				showable on one page.
 * 	- rp		Number of elements to return (per page)		
 *
 * @param $sql array
 * 			'dbPreStatement'	optional: Statement which will be executed before anything else. Usefull to create temporary views.
 * 			'dbColumns' 		Array of columns
 * 			'dbSearchColumns' 	Array of columns that can be searched with the like command (no 'counts' or 'id'(bigint)
 * 			'dbSortColumns'		optional; Array of column on that can be sorted
 * 			'dbTable' 			String db table
 * 			' ' 			optional; the joins String (including all JOIN statements)
 * 			'dbGroupBy' 		optional; the GROUP BY string
 * 			'dbWhere' 			optional; the WHERE statement string
 * 			'id' 				optional: id column, default 'id'
 * 			'acl_level'			optional: Required acl level. For valid values, have a look at the c_acl module (file c_acl.base.inc)
 *
 *			Default values:
 * 			$sql['dbPreStatement'] = '';
 * 			$sql['dbColumns'] = array();
 * 			$sql['dbSearchColumns'] = array();
 * 			$sql['dbSortColumns'] = array();
 * 			$sql['dbTable'] = '';
 * 			$sql['dbJoins'] = '';
 * 			$sql['dbGroupBy'] = '';
 * 			$sql['dbWhere'] = '';
 * 			$sql['id] = 'id';
 * 			$sql['acl_level'] = 'ACL_READ';
 *
 * @param $arguments array
 * 			Values for the query
 * 
 * @param $preArguments array
 * 			Values for the dbPreStatement statement
 * 
 * @return Array
 * 			[sEcho] => Site which is show
 * 			[iTotalRecords] => Total records without filtering
 * 			[iTotalDisplayRecords] => found records with filtering
 * 			[aaData] => Array of filtered and limited data from db as dbfields
 * @note If you do not like this (and you wont like it), do it better and shut up.
 */
function datatable_dbRequest($sql, $arguments = array(),
		$preArguments = array()) {
		  
	/* Set the db fields to select */
	if (!$sql['dbColumns'] || !$sql['dbTable'])
		return "Error! No dbColumns or dbTable";
	assert(isset($sql['dbSearchColumns']));
	$aColumns = $sql['dbColumns'];
	if (isset($sql['dbPreStatement'])) {
		if (false) {
			$noopeningbrakets = str_replace(
				'{',
				'drupal_',
				$sql['dbPreStatement']); // FIXME
			$noclosingbrakets = str_replace('}', '', $noopeningbrakets);
			print "<pre>" . $noclosingbrakets . "</pre>";
		}
		db_query($sql['dbPreStatement'], $preArguments);
	}
	if(!isset($sql['acl_level'])) {
		$sql['acl_level'] = 'ACL_READ';
	}

	$searchColumns = $sql['dbSearchColumns'];
	$sortColumns = isset($sql['dbSortColumns']) ? $sql['dbSortColumns']
			: $sql['dbColumns'];

	/* DB table to use */
	$Table = $sql['dbTable'];

	/* Joins to use */
	$sJoins = '';
	if (isset($sql['dbJoins'])) {
		$sJoins = $sql['dbJoins'];
	}

	/* Group */
	$sGroupBy = '';
	if (isset($sql['dbGroupBy'])) {
		$sGroupBy = ' GROUP BY ' . $sql['dbGroupBy'];
	}

	isset($sql['dbWhere']) ? $where = "WHERE " . $sql['dbWhere'] : $where = "";

	$idColumn = isset($sql['id']) ? $sql['id'] : "id";

	$sTable = $Table . " " . $sJoins . " ";

	$sortOrders = array(
			'asc',
			'desc'
	);

	if (isset($_POST['sortname'])) {
		$sortname = $_POST['sortname'];
		foreach ($sortColumns as $sortColumn) {
			foreach (explode(".", $sortColumn) as $sortCol) {
				$sortColumnsTemp[] = trim($sortCol);
				//make sure that "oneofmyids AS id" works (BURN AFTER READING!)
				foreach (explode("AS", $sortCol) as $sortCol2) {
					$sortColumnsTemp[] = trim($sortCol2);
				}
			}
		}
		/**
		 * WARNING: This is an ugly hack.... // FIXME
		 */
		if (!is_int(array_search($sortname, $sortColumnsTemp)))
			return "Error! Sortname not possible. '$sortname' is not in "
					. implode(", ", $sortColumnsTemp);
		$sortname = pg_escape_string($sortname);
	}
	if (isset($_POST['sortorder'])) {
		$sortorder = pg_escape_string($_POST['sortorder']);
		if (!is_int(array_search($sortorder, $sortOrders)))
			return "Error! Sortorder not possible";
	}
	// 	Not progressed, always search in all searchable columns
	if (isset($_POST['qtype'])) {
	 	$qtype = pg_escape_string($_POST['qtype']);
	}
	if (isset($_POST['query'])) {
		$query = $_POST['query'];
		if (!is_string($query))
			return "Error! Query not a string";
		$query = pg_escape_string($query);
	}

	/*
	 * Paging
	 */
	if (isset($_POST['page'])) {
		$pageNumber = (int)$_POST['page'];
		if ($pageNumber < 1)
			return "Error! Pagevalue '$pageNumber' is smaller than 1.";
	} else {
		$pageNumber = 1;
	}

	if (isset($_POST['rp'])) {
		$pagesize = (int)$_POST['rp'];
		if ($pagesize < 1)
			return "Error! Pagesize < 1";
	}

	if (isset($pageNumber) && isset($pagesize)) {
		$offset = ($pageNumber - 1) * $pagesize;
	} else {
		$offset = 0;
		$pagesize = 100;
	}

	/*
	 * Ordering
	 */
	$sOrder = '';
	if (isset($sortname)) {
		$sOrder = "ORDER BY " . $sortname . " " . $sortorder;
	}

	/*
	 * Filtering
	 * NOTE this does not match the built-in DataTables filtering which does it
	 * word by word on any field. It's possible to do here, but concerned about efficiency
	 * on very large tables, and MySQL's regex functionality is very limited
	 */
	($where == "") ? $sWhere = "" : $sWhere = $where . "";
	if (isset($query) && $query != "" && isset($qtype) && $qtype != "") {
	    if($qtype == "*"){	    
    		($sWhere == "") ? $sWhere = "WHERE (" : $sWhere .= " AND (";
    		for ($i = 0; $i < count($searchColumns); $i++) {
    			/**
    			 * yes, this is ia terrible hack, but I do not know how another solution to make sure
    			 * that all(?!) types can be used with LIKE
    			 */
    			$sWhere .= "LOWER(CAST(" . $searchColumns[$i]
    					. " AS TEXT)) LIKE LOWER(CAST('%$query%' AS TEXT)) OR ";
    		}
    		$sWhere = substr_replace($sWhere, "", -3);
    		$sWhere .= ')';
	    }
	    else
	        $sWhere = "WHERE LOWER(" . (string)$qtype . ") LIKE LOWER('%". (string)$query . "%')";
	}

	/*
	 * SQL queries
	 * Get data to display
	 */
	$columnsString = str_replace(" , ", " ", implode(", ", $aColumns));
	$fullQuery = "SELECT $columnsString FROM $sTable $sWhere $sGroupBy $sOrder";

	/* Data set length after filtering */
	$fullResult = db_query($fullQuery, $arguments);
	$fullRecords = $fullResult->fetchAll();

	/**
	 * Count number of accessible elements if an acl_id available
	 * 
	 * @note This is an expensive operation and should be moved into the
	 * database at some point.
	 */
	$numberOfAccessibleRows = 0;
	if (isset($fullRecords[0]->acl_id)) {
		foreach ($fullRecords as $record) {
			if (check_permission($record->acl_id, variable_get($sql['acl_level']))) {
				$numberOfAccessibleRows++;
			}
		}
	} else {
		$numberOfAccessibleRows = $fullResult->rowCount();
	}

	$output = array(
			'page' => $pageNumber,
			'total' => $numberOfAccessibleRows,
			'rows' => array()
	);

	$counter = 0;
	$validElementsCounter = 0;
	foreach ($fullRecords as $aRow) {
		if(++$counter <= $offset) {
			continue;
		} else if(++$validElementsCounter > $pagesize) {
			break;
		}
		$row = get_object_vars($aRow);
		if (!isset($aRow->acl_id)
				|| check_permission($aRow->acl_id, variable_get($sql['acl_level']))) {
			$output['rows'][] = array(
					'id' => $aRow->$idColumn,
					'cell' => $row
			);
		}
	}
	
	return $output;
}
?>